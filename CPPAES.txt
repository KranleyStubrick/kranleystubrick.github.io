// AES 128.cpp : This file contains the 'main' function. Program execution begins and ends there.
// https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf
// Goal is to make a console application that recursively encrypts bytes of any file in increments of 16 as is standard with aes.
// Going to make sure everything is functional first then research cipher block chaining and see if applicable/practical

#include <iostream>
#include <fstream>
#include <math.h>
#include <string>
#include <algorithm>
#include <bit>
#include <bitset>

using namespace std;

/* Galois field multiplication is achieved by modifying the "peasant's algorithm" because Rijndael's GF only takes 8 bit numbers.
 * "shift and add"  https://en.wikipedia.org/wiki/Multiplication_algorithm#Usage_in_computers 
 */

unsigned char galois_multiplication(unsigned char a, unsigned char b) { 

    unsigned char p = 0;
    unsigned char count;
    unsigned char high_bit_a;

    for (count = 0; count < 8; count++) {

        /*bitwise AND performed on b and hex 1( decimal 1 ) to determine if lowest order bit is set.
        * If lowest order bit is set, perform XOR assigment on p ( p = p ^ a ).*/

        if ((b & 1) == 1)   
            p ^= a;

        /*bitwise AND performed on a and hexadecimal 0x80(decimal 128) to determine if highest order bit is set.
        * result of the operation is stored in the unsigned char high_bit_a for future use.*/

        high_bit_a = (a & 0x80);    

        a <<= 1;

        /*If highest order bit of a was set before left shift assignment, perform XOR assignment on a (a = a ^ 0x1b( decimal 27 ))
        * Hexadecimal 0x1b represents the last 8 bits of Rijndaels irreducable polynomial x**8 + x**4 + x**3 + x + 1.*/

        if (high_bit_a == 0x80)
            a ^= 0x1b;

        b >>= 1;

    }

    return p;

}

void galois_antilog_table(unsigned char* atable) {  //Antilog table is a 16x16 value table created by repetitive multiplication of a generator number

    int count = 0;
    unsigned char start = 0x01;
    unsigned char gen = 0x03;

    while (count < 256) {  

        unsigned char roll = galois_multiplication(start, gen); 

        atable[count] = start;
        start = roll;

        count++;

    }
}

void galois_log_table(unsigned int* ltable, unsigned char* atable) {   //16x16 logarithm table generated by nested index assignment 
    for (int c = 0; c < 256; c++) 
        ltable[atable[c]] = c;

    ltable[0] = 0;
}

unsigned char find_mul_inv(unsigned int* ltable, unsigned char* atable, unsigned char a) {   //Finding multiplicative inverses via arithmetic performed an the previously generated antilog and log lookup tables
    if (a == 0)
        return 0;
    else
        return (atable[255 - ltable[a]]);
}

unsigned char fast_g_mul(unsigned int* ltable, unsigned char* atable, unsigned char a, unsigned char b) {  //Faster multiplication than utilized method. Based on antilog and log lookup tables
    return (atable[(ltable[a] + ltable[b]) % 255]);
}

unsigned char affine_transformation(unsigned int* ltable, unsigned char* atable, unsigned char a) {    //Rijndael s-box generation from arithmetic on alog & log lookup tables returns number to s_box_gen() for assignment

    unsigned char c, s, x;

    switch (a) {    //find_mul_inv
    case 0:
        s = x = 0;
        break;
    default:
        s = x = (atable[255 - ltable[a]]);
    }
    
    //s = x = find_mul_inv(ltable, atable, a);

    for (c = 0; c < 4; c++) {   //circular bit rotate left

        s = (s << 1) | (s >> 7);

        x ^= s;

    }
    x ^= 99;    //The particular value of 99 was chosen because it is a primitive element in the Galois field, which means that it generates the entire field when raised to successive powers.

    //This property makes it a good choice for use in the affine transformation of the S-box generation, helping to ensure that the output values of the S-box are highly non-linear and resistant to cryptanalysis.

    return x;
}

void s_box_gen(unsigned int* ltable, unsigned char* atable, unsigned char* s_box) { 

    unsigned int a;

    for (a = 0; a < 256; a++) 
        s_box[a] = affine_transformation(ltable, atable, a);    //again with leaf function and efficiency
    
}

void sub_bytes(unsigned char* input, unsigned char* s_box) {    //first (excluding initial round) step in encryption. substitute values in state matrix with values in the substitution box lookup table.

    for (int i = 0; i < 16; i++)
        input[i] = s_box[input[i]];

}

/*cram 4 bytes from an array into a 32 bit unsigned int(literally the same datatype as unsigned char) and call _rotr then shift and reassign bytes to a 4 byte array*/

void shift_rows(unsigned char* a, int b) { 

    uint32_t v;

    memmove(&v, a, sizeof(v));  //Second step in encryption(confusion). "copy" the contents of array a into one 32 bit unsigned int variable.

    switch (b) {
    case 0:
        v = _rotr(v, 8);    //little endian so have to use _rotr for a circular left (technically right) byte shift. left 1 byte
        break;
    case 1:
        v = _rotr(v, 16);   //left 2 bytes
        break;
    case 2:
        v = _rotr(v, 24);   //left 3 bytes
        break;
    }

    a[3] = (v >> 24) & 0xFF;    //processor architecture is little endian so have to extract by right shifting bits.
    a[2] = (v >> 16) & 0xFF;
    a[1] = (v >> 8) & 0xFF;
    a[0] = v & 0xFF;

}

void mix_columns(unsigned char* inpc, unsigned char* atable, unsigned int* ltable) {    //Third step in encryption(diffusion). This is a bit too complicated to fit on one line https://en.wikipedia.org/wiki/Rijndael_MixColumns

    unsigned char a[4];
    unsigned char c;

    for (c = 0; c < 4; c++)     
        a[c] = inpc[c];
    
    inpc[0] = (atable[(ltable[a[0]] + ltable[2]) % 255]) ^ (atable[(ltable[a[3]] + ltable[1]) % 255]) ^ (atable[(ltable[a[2]] + ltable[1]) % 255]) ^ (atable[(ltable[a[1]] + ltable[3]) % 255]);
    inpc[1] = (atable[(ltable[a[1]] + ltable[2]) % 255]) ^ (atable[(ltable[a[0]] + ltable[1]) % 255]) ^ (atable[(ltable[a[3]] + ltable[1]) % 255]) ^ (atable[(ltable[a[2]] + ltable[3]) % 255]);
    inpc[2] = (atable[(ltable[a[2]] + ltable[2]) % 255]) ^ (atable[(ltable[a[1]] + ltable[1]) % 255]) ^ (atable[(ltable[a[0]] + ltable[1]) % 255]) ^ (atable[(ltable[a[3]] + ltable[3]) % 255]);
    inpc[3] = (atable[(ltable[a[3]] + ltable[2]) % 255]) ^ (atable[(ltable[a[2]] + ltable[1]) % 255]) ^ (atable[(ltable[a[1]] + ltable[1]) % 255]) ^ (atable[(ltable[a[0]] + ltable[3]) % 255]);

}

void rotate(unsigned char* a) { //simplified shiftrows for other uses

    uint32_t v;

    memmove(&v, a, sizeof(v));

    v = _rotr(v, 8);

    a[3] = (v >> 24) & 0xFF;    
    a[2] = (v >> 16) & 0xFF;
    a[1] = (v >> 8) & 0xFF;
    a[0] = v & 0xFF;
}

unsigned char rcon(unsigned char inp) { //Round Constant

    unsigned char a = 1;

    if (inp == 0) 
        return 0;

    while (inp != 1) {
        a = galois_multiplication(a, 2);
        inp--;
    }
    return a;
    

}

void key_schedule_core(unsigned char* inp, unsigned char* s_box, unsigned char i) {

    char a;

    rotate(inp);

    for (a = 0; a < 4; a++)
        inp[a] = s_box[inp[a]];

    inp[0] ^= rcon(i);

}

void expand_key(unsigned char* in, unsigned char* s_box) {  //expand key takes initial 16 bit key and adds "garbage" values until size of key == 128, 192, 256. this is for 128  

    unsigned char t[4];
    unsigned char c = 16;
    unsigned char i = 1;
    unsigned char a;

    while (c < 176) {

        for (a = 0; a < 4; a++) 
            t[a] = in[a + c - 4];

        if (c % 16 == 0) {
            key_schedule_core(t, s_box, i);
            i++;
        }

        for (a = 0; a < 4; a++) {
            in[c] = in[c - 16] ^ t[a];
            c++;
        }
    }
}

//research cipher block chaining

int main()
{
   
    ifstream iFile;
    ofstream oFile;
    string file_name;

    iFile.open("fileIO.txt");   

    if (!iFile.is_open()) {
        cout << "Cannot open input file!!!";
        EXIT_FAILURE;
    }

    iFile >> noskipws;  

    int count = 0;
    unsigned char file_data[16];

    while (iFile >> file_data[count]) {
        cout << file_data[count] << "   ";
        count++;
    }

    iFile.close();

    unsigned char atable[256];
    unsigned int ltable[0x100];
    unsigned char substitution_box[256];

    galois_antilog_table(atable);
    galois_log_table(ltable, atable);   
    s_box_gen(ltable, atable, substitution_box);

    unsigned char key[192];  // i transposed for ease of logic cause I dont like the way the typical 2d state matrix looks and its easier for me to keep track of 1d arrays. will refactor later
    unsigned char correct_data[4][4];
    unsigned char correct_key[4][4];

    for (count = 0; count < 16; count++)
        key[count] = 0x1b;

    count = 0;

    for (int p = 0; p < 4; p++) {   //store key and data in 2d arrays for manip into correct aes format of state matrices
        for (int g = 0; g < 4; g++) {
            correct_data[g][p] = file_data[count];
            correct_key[g][p] = key[count];
            count++;
        }
    }

    count = 0;

    for (int k = 0; k < 4; k++) {   //regurgitate correct format back into 1d arrays
        for (int t = 0; t < 4; t++) {
            file_data[count] = correct_data[k][t];
            key[count] = correct_key[k][t];
            count++;
        }
    }

    expand_key(key, substitution_box);  //START OF ENCRYPTION

    unsigned char state[16];

    for (count = 0; count < 16; count++) {  //initial round

        state[count] = file_data[count] ^ key[count];

    }

    int keyloop = 16;

    for (int rounds = 1; rounds < 10; rounds++) {   //start encrypting

        sub_bytes(state, substitution_box);     //SubBytes 

        unsigned char shiftprep[4];
        int skip = 4;

        for (count = 0; count < 3; count++) {   //ShiftRows

            memcpy(shiftprep, state + skip, 4);    
            shift_rows(shiftprep, count);
            memcpy(state + skip, shiftprep, 4);     //purposefully overlap memory rather than push values with memmove

            skip += 4;

        }

        unsigned char mixprep[4];

        skip = 0;

        for (count = 0; count < 4; count++) {   //MixColumns

            memcpy(mixprep, state + skip, 4);    
            mix_columns(mixprep, atable, ltable);
            memcpy(state + skip, mixprep, 4);     //purposefully overlap memory rather than push values with memmove

            skip += 4;

        }

        int lcv;

        for (lcv = 0; lcv < 16; lcv++) {    //add_round_key
            state[lcv] ^= key[keyloop];
            keyloop++;
        }
    }

    sub_bytes(state, substitution_box); //last round

    unsigned char lastshift[4];
    int lastskip = 4;

    for (count = 0; count < 3; count++) {   //ShiftRows

        memcpy(lastshift, state + lastskip, 4);    
        shift_rows(lastshift, count);
        memcpy(state + lastskip, lastshift, 4);     //purposefully overlap memory rather than push values with memmove

        lastskip += 4;

    }

    count = 0;

    for (int r = 172; r < 188; r++) {
        state[count] ^= key[r];
        count++;
    }

    cout << "\n\nCiphertext is: \n\n";

    for (int l = 0; l < sizeof(state); l++)
        cout << state[l] << "   ";

    //END OF ENCRYPTION



    return 0;
}
